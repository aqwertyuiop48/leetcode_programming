/*
 * @lc app=leetcode id=770 lang=kotlin
 *
 * [770] Basic Calculator IV
 */

class Solution(private val evalmap: MutableMap<String, Int> = mutableMapOf(), private val prec: Map<String, Int> = mapOf("+" to 1, "-" to 1, "*" to 2)) {fun basicCalculatorIV(expression: String, evalvars: Array<String>, evalints: IntArray) = evalvars.indices.forEach { evalmap[evalvars[it]] = evalints[it] }.let { expression.replace(" ", "").let { expr -> generateSequence(0 to mutableListOf<String>()) { (i, tokens) -> when { i >= expr.length -> {null} expr[i] in "+-*()" -> {(i + 1) to tokens.apply { add(expr[i].toString()) }} expr[i].isDigit() -> {generateSequence(i) { j -> (j + 1).takeIf { it < expr.length && expr[it].isDigit() } }.last().let { j -> (j + 1) to tokens.apply { add(expr.substring(i, j + 1)) } }} expr[i].isLetter() -> {generateSequence(i) { j -> (j + 1).takeIf { it < expr.length && expr[it].isLetter() } }.last().let { j -> (j + 1) to tokens.apply { add(expr.substring(i, j + 1)) } }} else -> (i + 1) to tokens } }.last().second }.let { tokens -> tokens.fold(ArrayDeque<Map<List<String>, Int>>() to ArrayDeque<String>()) { (vals, ops), tok -> when { tok == "(" -> {vals to ops.apply { addFirst(tok) }} tok == ")" -> {generateSequence(vals to ops) { (v, o) -> o.first().takeIf { it != "(" }?.let { op -> o.removeFirst().let { applyOp(v.removeFirst(), v.removeFirst(), op) }.let { result -> v.apply { addFirst(result) } to o } } }.last().let { (v, o) -> v to o.apply { removeFirst() } }} tok in prec -> {generateSequence(vals to ops) { (v, o) -> o.firstOrNull()?.takeIf { it in prec && prec[it]!! >= prec[tok]!! }?.let { op -> o.removeFirst().let { applyOp(v.removeFirst(), v.removeFirst(), op) }.let { result -> v.apply { addFirst(result) } to o } } }.last().let { (v, o) -> v to o.apply { addFirst(tok) } }} else -> vals.apply { addFirst(parseToken(tok)) } to ops } }.let { (vals, ops) -> generateSequence(vals to ops) { (v, o) -> o.firstOrNull()?.let { op -> o.removeFirst().let { applyOp(v.removeFirst(), v.removeFirst(), op) }.let { result -> v.apply { addFirst(result) } to o } } }.last().first }.let { if (it.isEmpty()) emptyMap() else it.first() } }.entries.sortedWith(compareBy<Map.Entry<List<String>, Int>> { -it.key.size }.thenBy { it.key.joinToString("*") }).mapNotNull { (vars, coeff) -> coeff.takeIf { it != 0 }?.let { if (vars.isEmpty()) it.toString() else "$it*${vars.joinToString("*")}" } } } fun parseToken(tok: String) = when { tok.all { it.isDigit() } -> {mapOf(emptyList<String>() to tok.toInt())} evalmap.containsKey(tok) -> {mapOf(emptyList<String>() to evalmap[tok]!!)} else -> mapOf(listOf(tok) to 1) } fun applyOp(b: Map<List<String>, Int>, a: Map<List<String>, Int>, op: String) = when (op) { "+" -> {mutableMapOf<List<String>, Int>().apply { a.forEach { (k, v) -> this[k] = v } }.apply { b.forEach { (k, v) -> this[k] = (this[k] ?: 0) + v } }.filterValues { it != 0 }} "-" -> {mutableMapOf<List<String>, Int>().apply { a.forEach { (k, v) -> this[k] = v } }.apply { b.forEach { (k, v) -> this[k] = (this[k] ?: 0) - v } }.filterValues { it != 0 }} else -> mutableMapOf<List<String>, Int>().apply { a.forEach { (ka, va) -> b.forEach { (kb, vb) -> (ka + kb).sorted().let { merged -> this[merged] = (this[merged] ?: 0) + va * vb } } } }.filterValues { it != 0 } }}
