/*
 * @lc app=leetcode id=749 lang=kotlin
 *
 * [749] Contain Virus
 */

import java.util.*  import kotlin.collections.HashMap import kotlin.collections.HashSet class AreaInfo(val id: Int, val nodes: MutableSet<List<Int>> = HashSet(), var numExposed: Int = 0) class Solution( private val HEALTHY: Int = 0, private val UNHEALTHY: Int = 1, private val FOUND: Int = 2, private val CONTAMINATED: Int = 3, private val directions: List<Array<Int>> = listOf(arrayOf(0, 1), arrayOf(0, -1), arrayOf(1, 0), arrayOf(-1, 0)), private var exposed: MutableSet<List<Int>> = HashSet() ) {fun containVirus(isInfected: Array<IntArray>): Int = DeepRecursiveFunction<Int, Int> { totalWalls -> getInfectedAreas(isInfected).let { infectedAreas -> infectedAreas.values.maxByOrNull { it.numExposed }?.let { areaInfo -> areaInfo.nodes.first().let { start -> surroundWithWalls(start[0], start[1], isInfected, 0) }.also { infectedAreas.values.filter { it.id != areaInfo.id }.forEach { area -> HashSet(area.nodes).forEach { node -> expandVirus(node[0], node[1], isInfected, area, 0) } } }.let { walls -> callRecursive(totalWalls + walls) } } ?: totalWalls } }.invoke(0) fun expandVirus(i: Int, j: Int, isInfected: Array<IntArray>, areaInfo: AreaInfo, depth: Int): Unit = isInfected[i][j].takeIf { it != CONTAMINATED }?.run { areaInfo.nodes.add(listOf(i, j)).also { isInfected[i][j] = 1 }.run { directions.forEach { dir -> (dir[0] + i to dir[1] + j).let { (x, y) -> if (depth == 0 && isValid(x, y, isInfected) && isInfected[x][y] == HEALTHY) expandVirus(x, y, isInfected, areaInfo, depth + 1) } } } } ?: Unit fun surroundWithWalls(i: Int, j: Int, isInfected: Array<IntArray>, walls: Int): Int = if (isInfected[i][j] == CONTAMINATED) 0 else Unit.run { isInfected[i][j] = CONTAMINATED }.let { directions.fold(walls) { w, dir -> (dir[0] + i to dir[1] + j).let { (x, y) -> if (isValid(x, y, isInfected) && isInfected[x][y] == HEALTHY) w + 1 else w } } }.let { w -> directions.fold(w) { acc, dir -> (dir[0] + i to dir[1] + j).let { (x, y) -> if (isValid(x, y, isInfected) && isInfected[x][y] == FOUND) surroundWithWalls(x, y, isInfected, acc) else acc } } } fun getInfectedAreas(isInfected: Array<IntArray>): Map<Int, AreaInfo> = isInfected.indices.flatMap { i -> isInfected[0].indices.map { j -> i to j } }.filter { (i, j) -> isInfected[i][j] == 1 }.foldIndexed(HashMap<Int, AreaInfo>()) { areaId, map, pair -> map.apply { this[areaId] = AreaInfo(areaId).also { areaInfo -> exposed = HashSet<List<Int>>().also { _ -> searchInfected(pair.first, pair.second, isInfected, areaInfo) } } } } fun searchInfected(i: Int, j: Int, isInfected: Array<IntArray>, areaInfo: AreaInfo): Unit = if (isInfected[i][j] == CONTAMINATED) Unit else Unit.run { areaInfo.nodes.add(listOf(i, j)).also{isInfected[i][j] = FOUND} }.run { directions.forEach { dir -> (dir[0] + i to dir[1] + j).let { (x, y) -> if (isValid(x, y, isInfected) && !exposed.contains(listOf(x, y)) && isInfected[x][y] == HEALTHY) Unit.also { areaInfo.numExposed++ }.also { exposed.add(listOf(x, y)) } } } }.run { directions.forEach { dir -> (dir[0] + i to dir[1] + j).let { (x, y) -> if (isValid(x, y, isInfected) && isInfected[x][y] == UNHEALTHY) searchInfected(x, y, isInfected, areaInfo) } } }fun isValid(i: Int, j: Int, isInfected: Array<IntArray>): Boolean = i >= 0 && i < isInfected.size && j >= 0 && j < isInfected[0].size}